# -*- coding: utf-8 -*-
"""Chapter1_p2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r3FkWRPUXgk8Lz0Q8TS6k7NjK7vOurnD
"""



#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Oct  1 14:45:00 2025
@author: mario
"""
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import fsolve
from IPython.display import display, Math


# Enable LaTeX text rendering
plt.rcParams.update({
    "text.usetex": False,
    "font.family": "serif",
    # Optional: use a specific LaTeX engine (like pdflatex, xelatex)
    # "text.latex.preamble": r"\usepackage{amsmath}"
})
#%%

# Define the function to solve for beta
def equation_to_solve(beta, u, H, Vm):
    return H - u**2 * (1 - Vm / (u * np.tan(beta)))

# Function to calculate beta for a given r
def calculate_beta(r, H, omega, Vm):
    u = omega * r
    # Initial guess for beta (e.g., 45 degrees in radians)
    beta_guess = np.pi / 4
    # Solve for beta
    beta_solution, = fsolve(equation_to_solve, beta_guess, args=(u, H, Vm))
    return beta_solution


def calculate_beta_inlet(r, H, omega, Vm):
    u = omega * r
    # Initial guess for beta (e.g., 45 degrees in radians)
    # Solve for beta
    beta_inlet = np.arctan(Vm/u)
    return beta_inlet

# Known parameters
rho = 1000  # kg/m3
Din = 0.72  # m
Dext = 1.8  # m
Ain = np.pi * Din**2 / 4  # m2
Aext = np.pi * Dext**2 / 4  # m2
Rm = (Din + Dext) / 4  # m
omega = 250 * 2 * np.pi / 60
u2 = omega * Rm  # m/s
beta2 = 30 * np.pi / 180  # rad
alpha2 = 40 * np.pi / 180  # rad
Vm2 = u2 / (1 / np.tan(beta2) + 1 / np.tan(alpha2))
Vu2 = u2 - Vm2 / np.tan(beta2)
Vm1 = Vm2
u1 = u2
Q = Vm2 * (Aext - Ain)
gH = u2 * Vu2
W = rho * Q * gH
T = W / omega

# Display each variable with LaTeX formatting
display(Math(fr"V_{{m2}} = {Vm2:.2f}  \, \text{{m/s}}"))
display(Math(fr"Q = {Q:.2f} \, \text{{m}}^3/\text{{s}}"))
display(Math(fr"V_{{u2}} = {Vu2:.2f} \, \text{{m/s}}"))
display(Math(fr"W = {W/1000:.2f} \, \text{{kW}}"))
display(Math(fr"T = {T/1000:.2f} \, \text{{kNm}}"))
display(Math(fr"gH_{{z,\infty}} = {gH:.2f} \, \text{{J/Kg}}"))

# Range of r values
r_values = np.linspace(Din / 2, Dext / 2, 100)

# Calculate beta for each r
beta_o = np.array([calculate_beta(r, gH, omega, Vm2) for r in r_values])
beta_i  = np.array([calculate_beta_inlet(r, gH, omega, Vm2) for r in r_values])

# Specific r values to highlight
r1 = Din / 2
r2 = Dext / 2
r3 = Rm  # Average radius

# Find the corresponding beta values
beta1 = calculate_beta(r1, gH, omega, Vm2)
beta2_at_r2 = calculate_beta(r2, gH, omega, Vm2)
beta3 = calculate_beta(r3, gH, omega, Vm2)


beta_o1 = calculate_beta(r1, gH, omega, Vm2)
beta_o2 = calculate_beta(r2, gH, omega, Vm2)
beta_o3 = calculate_beta(r3, gH, omega, Vm2)


beta_i1 = calculate_beta_inlet(r1, gH, omega, Vm2)
beta_i2 = calculate_beta_inlet(r2, gH, omega, Vm2)
beta_i3 = calculate_beta_inlet(r3, gH, omega, Vm2)

# Plot
plt.figure(figsize=(8, 6))
plt.plot(r_values, beta_o * 180.0 / np.pi, label=r'$\beta_2$ vs. $r$')  # Convert beta_values to a NumPy array
plt.plot(r_values, beta_i  * 180.0 / np.pi, label=r'$\beta_1$ vs. $r$')  # Convert beta_values to a NumPy array

# Highlight specific points
#plt.scatter([r1, r2, r3], [beta1, beta2_at_r2, beta3] * 180.0 / np.pi, color='red', zorder=5)
plt.plot(r1, beta_o1 * 180.0 / np.pi,'o', color='red', zorder=2)
plt.plot(r2, beta_o2 * 180.0 / np.pi,'o', color='red', zorder=2)
plt.plot(r3, beta_o3 * 180.0 / np.pi,'o', color='red', zorder=2)

plt.plot(r1, beta_i1 * 180.0 / np.pi,'o', color='red', zorder=2)
plt.plot(r2, beta_i2 * 180.0 / np.pi,'o', color='red', zorder=2)
plt.plot(r3, beta_i3 * 180.0 / np.pi,'o', color='red', zorder=2)

# Annotate the points
# Annotate the points without arrows
plt.annotate(f'$r = {r1:.3f}$ m\n$\\beta_2 = {beta_o1 * 180.0 / np.pi:.2f}$',
             xy=(r1, beta_o1 * 180.0 / np.pi),
             xytext=(r1 + 0.025, beta_o1 * 180.0 / np.pi + 1))

plt.annotate(f'$r = {r2:.3f}$ m\n$\\beta_2 = {beta_o2 * 180.0 / np.pi:.2f}$',
             xy=(r2, beta_o2 * 180.0 / np.pi),
             xytext=(r2 - 0.025, beta_o2 * 180.0 / np.pi + 1.5))

plt.annotate(f'$r = {r3:.3f}$ m\n$\\beta_2 = {beta_o3 * 180.0 / np.pi:.2f}$',
             xy=(r3, beta_o3 * 180.0 / np.pi),
             xytext=(r3 + 0.025, beta_o3 * 180.0 / np.pi + 1.5))

plt.annotate(f'$r = {r1:.3f}$ m\n$\\beta_1 = {beta_i1 * 180.0 / np.pi:.2f}$',
             xy=(r1, beta_i1 * 180.0 / np.pi),
             xytext=(r1 , beta_i1 * 180.0 / np.pi - 12))

plt.annotate(f'$r = {r2:.3f}$ m\n$\\beta_1 = {beta_i2 * 180.0 / np.pi:.2f}$',
             xy=(r2, beta_i2 * 180.0 / np.pi),
             xytext=(r2 , beta_i2 * 180.0 / np.pi - 9))

plt.annotate(f'$r = {r3:.3f}$ m\n$\\beta_1 = {beta_i3 * 180.0 / np.pi:.2f}$',
             xy=(r3, beta_i3 * 180.0 / np.pi),
             xytext=(r3 , beta_i3 * 180.0 / np.pi - 9))


# Labels and title
plt.xlabel('$r$ (m)')
plt.ylabel(r'$\beta_2$ ($^\circ$)')
plt.ylim(0, 120)
plt.title('Plot of $\\beta_2$ as a function of $r$')
plt.legend()
plt.show()
